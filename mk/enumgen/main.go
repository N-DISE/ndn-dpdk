package main

import (
	"flag"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"strconv"
	"strings"
	"text/template"
)

func main() {
	var ta templateArgs
	typeFlag := flag.String("type", "", "list of types, delimited by comma")
	flag.StringVar(&ta.Guard, "guard", "", "#include guard name")
	outputFlag := flag.String("out", "", "output filename")
	flag.Parse()
	var typenames []string
	if *typeFlag != "" {
		typenames = strings.Split(*typeFlag, ",")
	}
	if flag.NArg() != 1 || len(typenames) == 0 || *outputFlag == "" {
		log.Fatal("Usage: enumgen -type=Type0,Type1 -guard=INCLUDE_GUARD -out=output.h path/to/package")
	}

	ta.Types = make(map[string]*enumDecl)
	for _, typename := range typenames {
		ta.Types[typename] = &enumDecl{typename, nil}
	}

	fset := token.NewFileSet()
	pkgs, e := parser.ParseDir(fset, flag.Arg(0), nil, 0)
	if e != nil {
		log.Fatal(e)
	}
	for _, pkg := range pkgs {
		file := ast.MergePackageFiles(pkg, 0)
		extractEnumConsts(ta.Types, file)
	}

	outFile, e := os.Create(*outputFlag)
	if e != nil {
		log.Fatal("cannot open output file", e)
	}
	defer outFile.Close()
	outputTpl.Execute(outFile, ta)
}

type templateArgs struct {
	Guard string
	Types map[string]*enumDecl
}

type enumDecl struct {
	Typename string
	Values   []enumValue
}

type enumValue struct {
	Const string
	Value int
}

func extractEnumConsts(m map[string]*enumDecl, file *ast.File) {
	for _, decl := range file.Decls {
		gdecl, ok := decl.(*ast.GenDecl)
		if !ok || gdecl.Tok != token.CONST {
			continue
		}
		typename := ""
		for i, spec := range gdecl.Specs {
			vspec := spec.(*ast.ValueSpec)
			if typeIdent, ok := vspec.Type.(*ast.Ident); ok {
				typename = typeIdent.String()
			}
			enumD, ok := m[typename]
			if !ok || len(vspec.Names) != 1 {
				continue
			}

			name := vspec.Names[0].String()
			value := i // assume iota
			if len(vspec.Values) == 1 {
				if valueLit, ok := vspec.Values[0].(*ast.BasicLit); ok {
					parsed, _ := strconv.ParseInt(valueLit.Value, 0, 32)
					value = int(parsed)
				}
			}

			enumD.Values = append(enumD.Values, enumValue{name, value})
		}
	}
}

const outputTemplate = `
{{- /* */ -}}
// <auto-generated> ndn-dpdk/mk/enumgen
#ifndef {{.Guard}}
#define {{.Guard}}
{{range .Types}}
typedef enum {{.Typename}} {
  {{- range .Values}}
  {{.Const}} = {{.Value}},
  {{- end}}
} {{.Typename}};
{{end}}
#endif // {{.Guard}}
`

var outputTpl = template.Must(template.New("").Parse(outputTemplate))
